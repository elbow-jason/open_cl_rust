#![allow(non_upper_case_globals)]
use std::marker::PhantomData;
use std::fmt::Debug;

use crate::open_cl::{
    // cl_command_execution_status,
    cl_command_queue,
    cl_command_queue_info,
    cl_command_queue_properties,
    cl_enqueue_nd_range_kernel,
    cl_enqueue_read_buffer,
    cl_enqueue_write_buffer,
    // cl_event,
    cl_finish,
    cl_mem,
    cl_release_command_queue,
    ClObject,
};
use crate::{
    // Count,
    // AsMutPointer,
    MemSize,
    Offset,
    DeviceMem,
    // Event,
    ClEvent,
    // UserEvent,
    EventList,
    Kernel,
    OpConfig,
    Output,
    ReadFromDeviceMem,
    Work,
    AsPointer,
    WriteToDeviceMem,
    HostBuffer,
};

#[repr(C)]
#[derive(Debug, Eq, PartialEq, Hash)]
pub struct CommandQueue{
    inner: cl_command_queue,
    _phantom: PhantomData<()>
}

impl ClObject<cl_command_queue> for CommandQueue {
    fn raw_cl_object(&self) -> cl_command_queue {
        self.inner
    }
}

impl CommandQueue {
    pub(crate) fn new(queue: cl_command_queue) -> CommandQueue {
        CommandQueue{
            inner: queue,
            _phantom: PhantomData
        }
    }


    /// Move data from the HostBuffer (probably a Vec<T> or &[T]) to the OpenCL cl_mem pointer.
    pub fn write_buffer<M, T>(
        &self,
        mem_obj: &M,
        buffer: &HostBuffer<T>,
        event_list: EventList,
        maybe_op_config: Option<OpConfig>,
    ) -> Output<()>
    where
        T: Sized,
        M: WriteToDeviceMem<T> + DeviceMem<T> + Debug
    {
        let op_cfg: OpConfig = maybe_op_config.unwrap_or_else(|| OpConfig::default());
        println!("write_buffer enqueuing {:?} to {:?}", buffer, mem_obj);
        cl_enqueue_write_buffer(
            self,
            mem_obj.cl_mem(),
            buffer,
            op_cfg.is_blocking.unwrap_or(true),
            event_list,
            op_cfg.writing_event,
        )
    }

    /// Move data from the OpenCL cl_mem pointer to the HostBuffer.
    pub fn read_buffer<'a, T, M>(
        &self,
        mem_obj: &'a M,
        buffer: &mut HostBuffer<T>,
        event_list: EventList,
        maybe_op_config: Option<OpConfig>,
    ) -> Output<()>
    where
        T: Sized,
        &'a M: ReadFromDeviceMem<T> + ClObject<cl_mem>,
    {
        println!("read_buffer enqueuing Buffer(offset: {:?}, mem_size: {:?}, pointer: {:?})", buffer.offset(), buffer.mem_size(), buffer.as_pointer());
    
        let op_cfg: OpConfig = maybe_op_config.unwrap_or_else(|| OpConfig::default());

        cl_enqueue_read_buffer(
            self,
            mem_obj,
            buffer,
            op_cfg.is_blocking.unwrap_or(false),
            event_list,
            op_cfg.writing_event,
        )
    }

    pub fn sync_enqueue_kernel(
        &self,
        kernel: Kernel,
        work: Work,
        event_list: EventList,
    ) -> Output<Option<ClEvent>> {
        let async_result = self.async_enqueue_kernel(kernel, work, event_list, None);
        if let Ok(_) = async_result {
            let () = cl_finish(self)?;
        }
        async_result
    }

    // NOTE: FIX EVENT EXECUTION TRACKING hint: _execution_event needs to be unique event
    // generated by user-land
    fn async_enqueue_kernel(
        &self,
        kernel: Kernel,
        work: Work,
        event_list: EventList,
        _execution_event: Option<ClEvent>,
    ) -> Output<Option<ClEvent>> {
        println!(
            "async_enqueue_kernel (self: {:?}, kernel: {:?}, work: {:?}, event_list: {:?}",
            self, kernel, work, event_list
        );
        cl_enqueue_nd_range_kernel(
            &self,
            &kernel.cl_object(),
            work.work_dim(),
            work.global_work_offset(),
            work.global_work_size(),
            work.local_work_size(),
            event_list,
        )
    }
}

impl Drop for CommandQueue {
    fn drop(&mut self) {
        println!("Dropping command_queue {:?}", self);
        cl_release_command_queue(&self.raw_cl_object())
            .unwrap_or_else(|e| panic!("Failed to cl_release_command_queue {:?}", e))
    }
}

bitflags! {
    pub struct CommandQueueProperties: cl_command_queue_properties {
        const OutOfOrderExecModeEnable = 1 << 0;
        const ProfilingEnable = 1 << 1;
        const OnDevice = 1 << 2;
        const OnDeviceDefault = 1 << 3;
    }
}

impl Default for CommandQueueProperties {
    fn default() -> CommandQueueProperties {
        CommandQueueProperties::ProfilingEnable
    }
}

crate::__codes_enum!(CommandQueueInfo, cl_command_queue_info, {
    Context => 0x1090,
    Device => 0x1091,
    ReferenceCount => 0x1092,
    Properties => 0x1093,
    Size => 0x1094,
    DeviceDefault => 0x1095
});
